/**********************************************************
 * Script to generate Array.sol file contains helpers to 
 * create dynamic arrays of variable sizes for solidity
 * base types.
 **********************************************************/

import fs from 'fs';

// @dev Add more types to the TARGETS object to generate more functions
const TARGETS = {
  uints: { // function name
    type: "uint256" // type
  },
  addresses: {
    type: 'address'
  },
  bytes4s: {
    type: 'bytes4'
  },
  bytes32s: {
    type: 'bytes32'
  },
  bytesList: {
    type: 'bytes',
    skipContains: true
  }
} as const;
// @dev MAX_SIZE controls the maximum size of the array that can be generated
// the script will create overloaded functions with 1 to MAX_SIZE arguments.
const MAX_SIZE = 8;
const MEMORY_IN_ARGS = {
  "bytes": true,
  "uint256": false,
  "address": false,
  "bytes4": false,
  "bytes32": false
}

const HEADER = `
// AUTOGENERATED FILE (bin/gen-array-helpers.ts) DON'T MODIFY DIRECTLY
// SPDX-License-Identifier: GPL-3.0-or-later
pragma solidity ^0.8;
`

const templateFnAssignments = (size: number): string => {
  let content = '';
  for (let j = 0; j < size; j++) {
    content += `    arr[${j}] = e${j};\n`
  }
  return content;
}

const maybeMemory = (type: string): string => {
  if (MEMORY_IN_ARGS[type]) {
    return ' memory';
  }
  return ''
}

const templateFnArgs = (type: string, size: number): string => {
  let content = '';
  for (let j = 0; j < size; j++) {
    content += `    ${type}${maybeMemory(type)} e${j}${j < size - 1 ? ',\n' : ''}`
  }
  return content;
}

const templateFunction = (fn: string, type: string, size: number) => `
function ${fn}(
${templateFnArgs(type, size)}
) pure returns (${type}[] memory arr) {
    arr = new ${type}[](${size});
${templateFnAssignments(size)}
    return arr;
}
`

const templateContains = (type: string) => `
function contains(${type}[] memory self, ${type}${maybeMemory(type)} value) pure returns(bool) {
    for (uint256 i = 0; i < self.length; i++) {
        if (self[i] == value) {
            return true;
        }
    }
    return false;
}
`

let fileContent = HEADER;
for (const [fn, config] of Object.entries(TARGETS)) {
  const { type } = config;
  for (let i = 1; i <= MAX_SIZE; i++) {
    fileContent += templateFunction(fn, type, i);
  }
  if (!config.skipContains) {
    fileContent += templateContains(type);
  }
}

fs.writeFileSync("src/Array.sol", fileContent);
